<?phpfunction pr($array = array()) {    echo '<pre>';    print_r($array);    echo '</pre>';}function prIP($array = array()) {    if ($_SERVER['REMOTE_ADDR'] == '90.176.43.89'){        echo '<pre>';        print_r($array);        echo '</pre>';    }}/** * Recursively strips slashes from all values in an array * * @param array $values Array of values to strip slashes * @return mixed What is returned from calling stripslashes * @link http://book.cakephp.org/view/709/stripslashes_deep */function stripslashes_deep($values) {    if (is_array($values)) {        foreach ($values as $key => $value) {            $values[$key] = stripslashes_deep($value);        }    } else {        $values = stripslashes($values);    }    return $values;}//Generating captchafunction captchaImageGeneration() {      $image = @imagecreatetruecolor(160, 50) or die("error");      $background = imagecolorallocate($image, 0xFF, 0xFF, 0xFF);      imagefill($image, 0, 0, $background);      $linecolor = imagecolorallocate($image, 0x29, 0xC7, 0x86);      $textcolor = imagecolorallocate($image, 0x00, 0x00, 0x00);      // draw random lines on canvas      for($i=0; $i < 4; $i++) {        imagesetthickness($image, rand(1,3));        imageline($image, 0, rand(0,60), 160, rand(0,60), $linecolor);      }      session_start();      // add random numbers to canvas      $captcha = '';      for($x = 15; $x <= 95; $x += 20) {        $captcha .= ($num = rand(0, 9));        imagechar($image, rand(4, 8), $x, rand(2, 14), $num, $textcolor);      }      //captcha numbers in session variable      $_SESSION['captcha'] = $captcha;      //save image and clean up      ob_start();      imagepng($image);      $imagedata = ob_get_contents();      ob_end_clean();      imagedestroy($image);      return "<img class='captcha-image' src='data:image/png;base64,".base64_encode($imagedata)."'/>";  }/** * [get_ip this function will get the current user ip address] * @return [type] [ip] */function get_ip() {        if (!empty($_SERVER['HTTP_CLIENT_IP'])) {        $ip_address = $_SERVER['HTTP_CLIENT_IP'];    } elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {        $ip_address = $_SERVER['HTTP_X_FORWARDED_FOR'];    } else {        $ip_address = $_SERVER['REMOTE_ADDR'];    }    return $ip_address;}/** * [encrypt_decrypt This function will encrypt or decrypt the string. (Email)] * @param  [string] $action [encrypt or decrypt] * @param  [string] $string [This is the text what we want to encrypt or decrypt] * @return [string]         [output] */function encrypt_decrypt($action, $string) {    $output = false;    $key = 'B2ET3cH!$*'.date("Ymd");    // initialization vector    $iv = md5(md5($key));    if( $action == 'encrypt' ) {        $output = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($key), $string, MCRYPT_MODE_CBC, $iv);        $output = strtr(base64_encode($output), '+/', '-_');        //$output = base64_encode($output);    }    else if( $action == 'decrypt' ){        //$output = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($key), base64_decode($string), MCRYPT_MODE_CBC, $iv);        $output = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($key), base64_decode(strtr($string, '-_', '+/')), MCRYPT_MODE_CBC, $iv);        $output = rtrim($output, "");    }    return $output;}/** * Gets an environment variable from available sources, and provides emulation * for unsupported or inconsistent environment variables (i.e. DOCUMENT_ROOT on * IIS, or SCRIPT_NAME in CGI mode). Also exposes some additional custom * environment information. * * @param string $key Environment variable name. * @return string Environment variable setting. */function env($key) {    if ($key == 'HTTPS') {        if (isset($_SERVER['HTTPS'])) {            return (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off');        }        return (strpos(env('SCRIPT_URI'), 'https://') === 0);    }    if ($key == 'SCRIPT_NAME') {        if (env('CGI_MODE') && isset($_ENV['SCRIPT_URL'])) {            $key = 'SCRIPT_URL';        }    }    $val = null;    if (isset($_SERVER[$key])) {        $val = $_SERVER[$key];    } elseif (isset($_ENV[$key])) {        $val = $_ENV[$key];    } elseif (getenv($key) !== false) {        $val = getenv($key);    }    if ($key === 'REMOTE_ADDR' && $val === env('SERVER_ADDR')) {        $addr = env('HTTP_PC_REMOTE_ADDR');        if ($addr !== null) {            $val = $addr;        }    }    if ($val !== null) {        return $val;    }    switch ($key) {        case 'SCRIPT_FILENAME':            if (defined('SERVER_IIS') && SERVER_IIS === true) {                return str_replace('\\\\', '\\', env('PATH_TRANSLATED'));            }            break;        case 'DOCUMENT_ROOT':            $name = env('SCRIPT_NAME');            $filename = env('SCRIPT_FILENAME');            $offset = 0;            if (!strpos($name, '.php')) {                $offset = 4;            }            return substr($filename, 0, strlen($filename) - (strlen($name) + $offset));            break;        case 'PHP_SELF':            return str_replace(env('DOCUMENT_ROOT'), '', env('SCRIPT_FILENAME'));            break;        case 'CGI_MODE':            return (PHP_SAPI === 'cgi');            break;        case 'HTTP_BASE':            $host = env('HTTP_HOST');            if (substr_count($host, '.') !== 1) {                return preg_replace('/^([^.])*/i', null, env('HTTP_HOST'));            }            return '.' . $host;            break;    }    return null;}function __autoload($nazev_tridy) {    try {        if (!file_exists(PATH_TO_CLASSES . strtolower($nazev_tridy) . '.php')) {            throw new exception;        }        require_once(PATH_TO_CLASSES . strtolower($nazev_tridy) . '.php');    } catch (Exception $vyjimka) {        die($vyjimka->getMessage());    }}function uses() {    $args = func_get_args();    foreach ($args as $file) {        require_once(PATH_TO_CLASSES . strtolower($file) . '.php');    }}if (!function_exists('getMicrotime')) {    /**     * Returns microtime for execution time checking     *     * @return float Microtime     */    function getMicrotime() {        list($usec, $sec) = explode(' ', microtime());        return ((float) $usec + (float) $sec);    }}/** * Convenience method for htmlspecialchars. * * @param string $text Text to wrap through htmlspecialchars * @param string $charset Character set to use when escaping. Defaults to config value in 'App.encoding' or 'UTF-8' * @return string Wrapped text * @link http://book.cakephp.org/view/1132/h */function h($text, $charset = null) {    if (is_array($text)) {        return array_map('h', $text);    }    $defaultCharset = 'UTF-8';    if ($charset) {        return htmlspecialchars($text, ENT_QUOTES, $charset);    } else {        return htmlspecialchars($text, ENT_QUOTES, $defaultCharset);    }}/** * Merge a group of arrays * * @param array First array * @param array Second array * @param array Third array * @param array Etc... * @return array All array parameters merged into one * @link http://book.cakephp.org/view/1124/am */function am() {    $r = array();    $args = func_get_args();    foreach ($args as $a) {        if (!is_array($a)) {            $a = array($a);        }        $r = array_merge($r, $a);    }    return $r;}function clear_checkbox($arr = array()) {    foreach ($arr as $key => &$value) {        if (is_array($value)) {            $value = clear_checkbox($value);        } else {            if ($value == 'on' && isset($arr[$key . '_chck']))                $value = 1;        }    }    return $arr;}/* Artur Chlad *//** * regexp search in non-casesensitive mode * @param string $patterm without //i * @param string $subject tested string * @return boolean true if any finded */function regexp($pattern, $subject) {    $pattern = "/{$pattern}/i";    return (bool) preg_match($pattern, $subject);}/** * regexp replace in non-casesensitive mode * @param string $patterm without //i * @param string $patterm template for result * @param string $subject tested string * @return string filled template */function regexp_replace($pattern, $replacement, $subject) {    $pattern = "/{$pattern}/i";    return preg_replace($pattern, $replacement, $subject, 1);}/** * @param string $s xml string * @return string formated xml in htmml and highlighting */function xml_highlight($s) {    $s = htmlspecialchars($s);    $s = preg_replace("#&lt;([/]*?)(.*)([\s]*?)&gt;#sU",                    "<font color=\"#0000FF\">&lt;\\1\\2\\3&gt;</font>", $s);    $s = preg_replace("#&lt;([\?])(.*)([\?])&gt;#sU",                    "<font color=\"#800000\">&lt;\\1\\2\\3&gt;</font>", $s);    $s = preg_replace("#&lt;([^\s\?/=])(.*)([\[\s/]|&gt;)#iU",                    "&lt;<font color=\"#808000\">\\1\\2</font>\\3", $s);    $s = preg_replace("#&lt;([/])([^\s]*?)([\s\]]*?)&gt;#iU",                    "&lt;\\1<font color=\"#808000\">\\2</font>\\3&gt;", $s);    $s = preg_replace("#([^\s]*?)\=(&quot;|')(.*)(&quot;|')#isU",                    "<font color=\"#800080\">\\1</font>=<font color=\"#FF00FF\">\\2\\3\\4</font>", $s);    $s = preg_replace("#&lt;(.*)(\[)(.*)(\])&gt;#isU",                    "&lt;\\1<font color=\"#800080\">\\2\\3\\4</font>&gt;", $s);    return nl2br($s);}/** * @param string $qry SQL query * @param handler $connection database conection handler * @return array of assoc and index arrays query results */function qry_arr($qry, $connection) {    $result = mysql_query($qry, $connection);    $return = array();    while ($row = mysql_fetch_array($result)) {        $return[] = $row;    }    return $return;}/** * @param string $qry SQL query * @param handler $connection database conection handler * @return array of assoc arrays query results */function qry_ass($qry, $connection) {    $result = mysql_query($qry, $connection);    $return = array();    while ($row = mysql_fetch_assoc($result)) {        $return[] = $row;    }    return $return;}/** * alternative to pr()  (show null) * @param object * @param object *  ... * @param object */function dump() {    echo '<pre>';    ob_start();    $args = func_get_args();    foreach ($args as $a) {        var_dump($a);    }    $out = ob_get_clean();    echo str_replace("=>\n", "=>", $out);    echo '</pre>';}/**  Wraps ternary operations. If $condition is a non-empty value, $val1 is returned, otherwise $val2.  Don't use for isset() conditions, or wrap your variable with @ operator:  Example: * * `ife(isset($variable), @$variable, 'default');` * * @param mixed $condition Conditional expression * @param mixed $val1 Value to return in case condition matches * @param mixed $val2 Value to return if condition doesn't match * @return mixed $val1 or $val2, depending on whether $condition evaluates to a non-empty expression. * @link http://book.cakephp.org/view/1133/ife * @deprecated Will be removed in 2.0 */function ife($condition, $val1 = null, $val2 = null) {    if (!empty($condition)) {        return $val1;    }    return $val2;}/** * reurn substring in multibyte string wihout ending parted word * */function mb_substrws($text, $length = 180) {    $text = strip_tags($text);    if ((mb_strlen($text) > $length)) {        $whitespaceposition = mb_strpos($text, ' ', $length) - 1;        if ($whitespaceposition > 0) {            $chars = count_chars(mb_substr($text, 0, ($whitespaceposition + 1)), 1);            if ($chars[ord('<')] > $chars[ord('>')]) {                $whitespaceposition = mb_strpos($text, ">", $whitespaceposition) - 1;            }            $text = mb_substr($text, 0, ($whitespaceposition + 1));        }        // close unclosed html tags        if (preg_match_all("|(<([\w]+)[^>]*>)|", $text, $aBuffer)) {            if (!empty($aBuffer[1])) {                preg_match_all("|</([a-zA-Z]+)>|", $text, $aBuffer2);                if (count($aBuffer[2]) != count($aBuffer2[1])) {                    $closing_tags = array_diff($aBuffer[2], $aBuffer2[1]);                    $closing_tags = array_reverse($closing_tags);                    foreach ($closing_tags as $tag) {                        $text .= '</' . $tag . '>';                    }                }            }        }    }    return $text;}/** * return string transform into url frienldly format * @param string * @return string */function friendly_uri($title) {    static $convertTable = array('á' => 'a', 'Á' => 'A', 'ä' => 'a', 'Ä' => 'A', 'č' => 'c', 'Č' => 'C', 'ď' => 'd', 'Ď' => 'D', 'é' => 'e', 'É' => 'E', 'ě' => 'e', 'Ě' => 'E', 'ë' => 'e', 'Ë' => 'E', 'í' => 'i', 'Í' => 'I', 'ï' => 'i', 'Ï' => 'I', 'ľ' => 'l', 'Ľ' => 'L', 'ĺ' => 'l', 'Ĺ' => 'L', 'ň' => 'n', 'Ň' => 'N', 'ń' => 'n', 'Ń' => 'N', 'ó' => 'o', 'Ó' => 'O', 'ö' => 'o', 'Ö' => 'O', 'ô' => 'o', 'Ô' => 'O', 'ř' => 'r', 'Ř' => 'R', 'ŕ' => 'r', 'Ŕ' => 'R', 'š' => 's', 'Š' => 'S', 'ś' => 's', 'Ś' => 'S', 'ť' => 't', 'Ť' => 'T', 'ú' => 'u', 'Ú' => 'U', 'ů' => 'u', 'Ů' => 'U', 'ü' => 'u', 'Ü' => 'U', 'ý' => 'y', 'Ý' => 'Y', 'ÿ' => 'y', 'Ÿ' => 'Y', 'ž' => 'z', 'Ž' => 'Z', 'ź' => 'z', 'Ź' => 'Z',    );    $title = strtolower(strtr($title, $convertTable));    $title = preg_replace('/[^a-zA-Z0-9]+/u', '-', $title);    $title = str_replace('--', '-', $title);    $title = trim($title, '-');    return $title;}//generates passwordfunction generatePassword($length = 8) {    // initialize variables    $password = "";    $i = 0;    $possible = "0123456789bcdfghjkmnpqrstvwxyz";    // add random characters to $password until $length is reached    while ($i < $length) {        // pick a random character from the possible ones        $char = substr($possible, mt_rand(0, strlen($possible) - 1), 1);        // we don't want this character if it's already in the password        if (!strstr($password, $char)) {            $password .= $char;            $i++;        }    }    return $password;}/** * foremated price * * */function fp($price, $currency=false) {    //possibilities(from ListCurrency):id	name	code	prefix	suffix	rate	quantity	count_after_point	rounding_count	created	updated	kos	status    if ($currency === false) {        $currency['suffix'] = 'Kč';        $currency['count_after_point'] = 2;    }    return sprintf("%0.{$currency['count_after_point']}f". (',' != substr($currency['suffix'], 0, 1)?"&nbsp;":'') ."%s", $price, $currency['suffix']);}function fpCeil($price, $currency=false) {    //possibilities(from ListCurrency):id	name	code	prefix	suffix	rate	quantity	count_after_point	rounding_count	created	updated	kos	status    if ($currency === false){        $currency['suffix'] = 'Kč';        $currency['count_after_point'] = 2;    }    return sprintf("%0.{$currency['count_after_point']}f %s", Ceil($price), $currency['suffix']);}/** * formated list from string; * * */function ul($str = '') {    if (!empty($str)) {        $nstr = '<ul><li>';        $nstr .= str_replace("\n", '</li><li>', $str);        $nstr .= '</li></ul>';        return $nstr;    }    return $str;}/* * improved base64  - you can use decoded string safely in url */function urlsafe_b64encode($string) {    $data = base64_encode($string);    $data = str_replace(array('+', '/', '='), array('-', '_', ''), $data);    return $data;}/* * improved base64  - decode string encoded by urlsafe_b64encode */function urlsafe_b64decode($string) {    $data = str_replace(array('-', '_'), array('+', '/'), $string);    $mod4 = strlen($data) % 4;    if ($mod4) {        $data .= substr('====', $mod4);    }    return base64_decode($data);}// array_key_search recursivly - for multidimensial arrayfunction array_key_exists_r($needle, $haystack) {    $result = array_key_exists($needle, (array) $haystack);    if ($result)        return $result;    foreach ((array) $haystack as $v) {        if (is_array($v)) {            $result = array_key_exists_r($needle, $v);        }        if ($result) {            return $result;        }    }    return $result;}// founded at php.net in comment to array_search function//There were two previous entries for having a recursive search. The first one only searched for values, second one for values with an optional key.//But both of those stopped after they found an entry. I needed, that it searches recursive, with optional key and returns me all matches found in the array.//So I wrote this function://needle is the value you search, haystack is the array of course, key is the optional key in the array where the needle should be. path should be never set on intial call. its an internal used variable.//It returns an array $path with the array entry 'found' where you can find all found groups. In these groups you have the array which holds the keys to find the data.//I hope this helps some of you.//If you call it with this://////    $right_side = array ('foo' => 'alpha', 'bar' => 'beta', 'delta' => 'gamma', 'gamma' => 'delta');//    $value = 'beta';//    $key = 'bar';//    $pos = array_search_recursive_all($value, $right_side, $key);//////You will find in $pos this data////Array//(//    [level] => -1//    [work] => Array//        (//        )////    [found] => Array//        (//            [0] => Array//                (//                    [0] => bar//                )////        )////)function array_search_recursive_all($needle, $haystack, $key=false, $path = NULL) {    if (!$path['level'])        $path['level'] = 0;    if (!$path['work'])        $path['work'] = array();    if (!is_array($haystack))        $haystack = array();    // go through the array,    foreach ($haystack as $_key => $_value) {        // only value matches        if (is_scalar($_value) && $_value == $needle && !$key) {            $path['work'][$path['level']] = $_key;            $path['found'][] = $path['work'];        }        // key and value matches        elseif (is_scalar($_value) && $_value == $needle && $_key == $key) {            $path['work'][$path['level']] = $_key;            $path['found'][] = $path['work'];        } elseif (is_array($_value)) {            // add position to working            $path['work'][$path['level']] = $_key;            // we will up a level            $path['level'] += 1;            // call recursive            $path = array_search_recursive_all($needle, $_value, $key, $path);        }    }    // cut all that is >= level    array_splice($path['work'], $path['level']);    // step back a level    $path['level'] -= 1;    return $path;}/* * formats number cut all zeros in end of number */function cutzero($value) {    return preg_replace("/(\.\d+?)0+$/", "$1", $value) * 1;}function fullArrayDiff($left, $right) {     return array_diff(array_merge($left, $right), array_intersect($left, $right)); }     function file_exists_2($filePath){    return ($ch = curl_init($filePath)) ? @curl_close($ch) || true : false;}function multipleExplode($delimiters = array(), $string = ''){     $mainDelim=$delimiters[count($delimiters)-1]; // dernier         array_pop($delimiters);         foreach($delimiters as $delimiter){             $string= str_replace($delimiter, $mainDelim, $string);         }     $result= explode($mainDelim, $string);     return $result; } function formatBytes($b,$p = null) {    /**     *      * @author Martin Sweeny     * @version 2010.0617     *      * returns formatted number of bytes.      * two parameters: the bytes and the precision (optional).     * if no precision is set, function will determine clean     * result automatically.     *      **/    $units = array("B","kB","MB","GB","TB","PB","EB","ZB","YB");    $c=0;    if(!$p && $p !== 0) {        foreach($units as $k => $u) {            if(($b / pow(1024,$k)) >= 1) {                $r["bytes"] = $b / pow(1024,$k);                $r["units"] = $u;                $c++;            }        }        return number_format($r["bytes"],2) . " " . $r["units"];    } else {        return number_format($b / pow(1024,$p)) . " " . $units[$p];    }}function mycrypt($pass){    $default_crypt = 'md5';    if (CLIENTS::exist('crypt') == false){        $method = $default_crypt;    } else {        $method = CLIENTS::get('crypt');        if (!in_array($method,array('md5', 'sha1', 'sha1md5')))            $method = $default_crypt;    }    switch($method){        case 'md5':            return md5($pass);            break;        case 'sha1':            return sha1($pass);            break;        case 'sha1md5':            return sha1(md5($pass));            break;    }}function getF($array){    return isset($array[0])?$array[0]:null;}/** * Function which converts an xml file to php array * @param null $path */function read_xml($path = null){    if($path === null){        return false;    }    if(!file_exists($path)){        return false;    }    // Convert the file    ob_start();    require $path;    $xml = ob_get_clean();    $xml = simplexml_load_string($xml,'SimpleXMLElement', LIBXML_NOCDATA);    $json = json_encode($xml);    $result = json_decode($json, TRUE);    return $result;}?>