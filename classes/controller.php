<?phpclass Controller{    var $name = '';    //var $helpers = array('Html', 'ViewIndex', 'Wapis');    var $helpers = array();    var $components = array();    var $predefined_components = array('Session');    var $beforeFiltered = true;    var $params = array();    var $data = array();    var $layoutPath = null;    var $autoRender = true;    var $autoLayout = true;    var $layout = 'default';    var $rendered = false;    var $page_caption = '';    var $viewPath;    var $uses = array();    var $bModifyDbSource = false;    var $bCreateDbSource = false;    var $main_page = false;    /**     * Obsahuje promenne, ktere jsou obsazeny ve view     *     * @var array     * @access public     */    var $viewVars = array();    /**     * Constructor.     *     */    function __construct()    {        if ($this->name === null) {            $r = null;            if (!preg_match('/(.*)Controller/i', get_class($this), $r)) {                die(__("Controller::__construct() : Can not get or parse my own class name, exiting."));            }            $this->name = $r[1];        }        if ($this->viewPath == null) {            $this->viewPath = Inflector::underscore($this->name);        }        $this->modelClass = Inflector::classify($this->name);        $this->modelKey = Inflector::underscore($this->modelClass);        //$this->Component =  new Component();        $childMethods = get_class_methods($this);        $parentMethods = get_class_methods('Controller');        foreach ($childMethods as $key => $value) {            $childMethods[$key] = strtolower($value);        }        foreach ($parentMethods as $key => $value) {            $parentMethods[$key] = strtolower($value);        }        $this->methods = array_diff($childMethods, $parentMethods);    }    public function beforeLoadModel()    {    }    function initClasses()    {        foreach (am($this->components, $this->predefined_components) as $com_ar => $com_name) {            if (is_array($com_name)) {                $class_name = Inflector::camelize($com_ar);                $component_file = SELFPATH . $com_name['file'];            } else {                $class_name = Inflector::camelize($com_name);                $component_file = Paths::findPath('component', Inflector::underscore($com_name) . ".php");                if ($component_file == null)                    die('File "' . Inflector::underscore($com_name) . ".php" . '" of a component has not been found');            }            require_once($component_file);            $this->{$class_name} = new $class_name();            $this->{$class_name}->startup($this);        }        $this->beforeLoadModel();        if (isset($this->uses) && count($this->uses) > 0)            foreach ($this->uses as $model) {                $this->loadModel($model);            }    }    function dispatchMethod($method, $params = array())    {        switch (count($params)) {            case 0:                return $this->{$method}();            case 1:                return $this->{$method}($params[0]);            case 2:                return $this->{$method}($params[0], $params[1]);            case 3:                return $this->{$method}($params[0], $params[1], $params[2]);            case 4:                return $this->{$method}($params[0], $params[1], $params[2], $params[3]);            case 5:                return $this->{$method}($params[0], $params[1], $params[2], $params[3], $params[4]);            default:                return call_user_func_array(array(&$this, $method), $params);                break;        }    }    /**     * Ulozi promenou pro pouziti ve view template     *     * @param mixed $one string nebo array, vstupni promenna     * @param mixed $two Value in case $one is a string (which then works as the key).     * Unused if $one is an associative array, otherwise serves as the values to $one's keys.     * @return void     * @access public     */    public function set($one, $two = null)    {        $data = array();        if (is_array($one)) {            if (is_array($two)) {                $data = array_combine($one, $two);            } else {                $data = $one;            }        } else {            $data = array($one => $two);        }        $this->viewVars = array_merge($this->viewVars, $data);    }    /**     * Called before the controller action.     *     * @access private     */    function beforeFilter()    {        $this->main_page = ($this->params['url']['url'] == '/');    }    /**     * Called after the controller action is run, but before the view is rendered.     *     * @access private     */    public function beforeRender()    {    }    public function afterRender($output)    {        return $output;    }    /**     * Called after the controller action is run and rendered.     *     * @access private     */    function afterFilter()    {    }    function render($path = null)    {        $this->beforeRender();        $out = '';        foreach ($this->helpers as $hlp) {            $class_name = $hlp . 'Helper';            $helper_file = Paths::findPath('helper', Inflector::underscore($hlp) . ".php");            if ($helper_file == null)                die('File "' . Inflector::underscore($hlp) . '.php" of the helper has been found');            require_once ($helper_file);            $tmp_hlp = new $class_name();            $tmp_hlp->data = $this->data;            $this->set(Inflector::underscore($hlp), $tmp_hlp);            unset($tmp_hlp);        }            if ($path == null)            $path = Inflector::underscore($this->name) . '/' . $this->action;        extract($this->viewVars);        if ($this->autoRender == 1) {            $view_file = Paths::findPath('view', "$path.ctp");            if ($view_file == null) {                die("View file $path.ctp has not been found.");                log::write("Layout neexistuje '$view_file'");            }            ob_start();            include($view_file);            $out = ob_get_clean();        }        $layout_file = Paths::findPath('layout', "{$this->layout}.ctp");        if ($layout_file == null) {            die("Layout file <strong>{$this->layout}.ctp</strong> has not been found!");            log::write("LLayout does not exist '$layout_file'");        }        if ($this->autoLayout === true) {            $main_content = $out;            ob_start();            include ($layout_file);            $out = ob_get_clean();        }        $this->rendered = true;        $out = $this->afterRender($out);        return $out;    }    function loadModel($model)    {            require_once('app/app_model.php');        $model_file = Paths::findPath('model', Inflector::underscore($model) . ".php");        if ($model_file == null) {            if ($this->bCreateDbSource) {                /*                 * create new db_source files xml and model START                 */                $table_name = Inflector::pluralize(Inflector::underscore($model));                $modsss->use_schema = false;                $modsss = new Model($this, false);                $res = $modsss->query("show columns from fastest__$table_name");                //    if($model == 'Zprava'){                //        var_dump($model_file) ;                //        exit('wpada');                //    }                if ($res) {                    //db_source                    Paths::getPath('db_source', $sPrName) . Inflector::underscore($model) . '.xml';                    $h = fopen(Paths::getPath('db_source', $sPrName) . Inflector::underscore($model) . '.xml', 'w+');                    fwrite($h, "<source>\n\t\t<table>{$table_name}</table>\n\t\t<cols>\n");                    while ($row = mysql_fetch_array($res)) {                        if ($row['Extra'] == 'auto_increment')                            $sAutoIncrement = "autoincrement='true'";                        else                            $sAutoIncrement = '';                        if ($row['Key'] == 'PRI')                            $sPrimaryKey = "index='primary'";                        else                            $sPrimaryKey = '';                        fwrite($h, "\t\t\t\t <col $sAutoIncrement type='{$row['Type']}' $sPrimaryKey>{$row['Field']}</col>\n");                        //                $row['Field'] =                        //                $row['Type'] =                        //                $row['Null'] =                        //                $row['Key'] =                        //                $row['Default'] =                        //                $row['Extra'] =                    }                    $ret = fwrite($h, "\t\t</cols>\n</source>");                    fclose($h);                    //model                    $h = fopen(Paths::getPath('model', $sPrName) . Inflector::underscore($model) . '.php', 'w+');                    fwrite($h,                        "<?php \n class $model extends AppModel {\n    var \$debug = false;    var \$name = '$model';    public \$con_kos = false;    public \$con_status = false;\n\n}\n?>");                    fclose($h);                    $model_file = Paths::findPath('model', Inflector::underscore($model) . ".php");                    if (!$model_file) {                        die('Model file ' . Inflector::underscore($model) . ".php" . ' has not been found');                    }                    require_once($model_file);                } else {                    /*                     * create new db_source files xml and model END                     */                    die('Model file ' . Inflector::underscore($model) . ".php" . ' has not been found');                }            } else {                die('Model file ' . Inflector::underscore($model) . ".php" . ' has not been found');            }        } else {            require_once($model_file);            if ($this->bModifyDbSource) {                /*                 * create new db_source files xml and model START                 */                $table_name = Inflector::pluralize(Inflector::underscore($model));                $modsss = new $model($this, false);                $res = $modsss->query("show columns from fastest__$table_name");                if ($res) {                    //db_source                    Paths::getPath('db_source', $sPrName) . Inflector::underscore($model) . '.xml';                    $h = fopen(Paths::getPath('db_source', $sPrName) . Inflector::underscore($model) . '.xml', 'w+');                    fwrite($h, "<source>\n\t\t<table>wapis__{$table_name}</table>\n\t\t<cols>\n");                    while ($row = mysql_fetch_array($res)) {                        if ($row['Extra'] == 'auto_increment')                            $sAutoIncrement = "autoincrement='true'";                        else                            $sAutoIncrement = '';                        if ($row['Key'] == 'PRI')                            $sPrimaryKey = "index='primary'";                        else                            $sPrimaryKey = '';                        fwrite($h, "\t\t\t\t <col $sAutoIncrement type='{$row['Type']}' $sPrimaryKey>{$row['Field']}</col>\n");                        //                $row['Field'] =                        //                $row['Type'] =                        //                $row['Null'] =                        //                $row['Key'] =                        //                $row['Default'] =                        //                $row['Extra'] =                    }                    $ret = fwrite($h, "\t\t</cols>\n</source>");                    fclose($h);                    //model                    /*                      $h = fopen(Paths::getPath('model', $sPrName) . Inflector::underscore($model) . '.php', 'w+');                      fwrite($h,                      "<?php \n class $model extends AppModel {\n                      var \$debug = false;                      var \$name = '$model';                      public \$con_kos = false;                      public \$con_status = false;\n\n                      }                      \n                      ?>"); */                    //                fclose($h);                    //                $model_file = Paths::findPath('model', Inflector::underscore($model) . ".php");                    //                if (!$model_file) {                    //                    die('Soubor pro model ' . Inflector::underscore($model) . ".php" . ' nebyl nalezen');                    //                }                } else {                    /*                     * create new db_source files xml and model END                     */                    die('Model file ' . Inflector::underscore($model) . ".php" . ' has not been found');                }            }        }        $this->$model = new $model($this);    }//    function renderElement($element = null, $parameters = array()) {//        foreach ($this->helpers as $hlp) {//            $class_name = $hlp . 'Helper';//            if (!isset($this->{$class_name})) {//                $helper_file = Paths::findPath('helper', Inflector::underscore($hlp) . ".php");//                if ($helper_file == null)//                    die('Soubor pro helper "' . Inflector::underscore($hlp) . '.php" nebyl nalezen');//                require_once ($helper_file);//                $this->{$class_name} = new $class_name();//                $this->{$class_name}->data = $this->data;//            }//            $parameters[Inflector::underscore($hlp)] = $this->{$class_name};//        }//        ob_start();//        $parameters = array_merge($this->viewVars, $parameters);//        extract($parameters);//        $element_file = Paths::findPath('element', "{$element}.ctp");//        if ($element_file == null)//            die("Soubor $element_file pro element nebyl nalezen");//        include($element_file);//        return ob_get_clean();//    }    function renderElement($element = null, $parameters = array())    {        foreach ($this->helpers as $hlp) {            $this->initHelper($hlp);        }        ob_start();        $parameters = array_merge($this->viewVars, $parameters);        extract($parameters);        $element_file = Paths::findPath('element', "$element.ctp");        if ($element_file == null)            die ("Element file $element.ctp has not been found.");        include($element_file);        return ob_get_clean();    }    function initHelper($hlp)    {        if (!isset($this->viewVars[Inflector::underscore($hlp)])) {            $class_name = $hlp . 'Helper';            $helper_file = Paths::findPath('helper', Inflector::underscore($hlp) . ".php");            if ($helper_file == null)                die('Helper file"' . Inflector::underscore($hlp) . '.php" has not been found');            require_once ($helper_file);            $tmp_hlp = new $class_name();            $tmp_hlp->data = $this->data;            if (function_exists('__startup'))                $tmp_hlp->__startup();            $this->set(Inflector::underscore($hlp), $tmp_hlp);        } else {            $tmp_hlp = $this->viewVars[Inflector::underscore($hlp)];        }        if (isset($tmp_hlp->helpers)) {            foreach ($tmp_hlp->helpers AS $hlp_sub) {                if (isset($this->viewVars[Inflector::underscore($hlp_sub)])) {                    $tmp_hlp->{Inflector::underscore($hlp_sub)} = $this->viewVars[Inflector::underscore($hlp_sub)];                } else {                    $this->initHelper($hlp_sub);                    $this->viewVars[Inflector::underscore($hlp_sub)];                    $tmp_hlp->{Inflector::underscore($hlp_sub)} = $this->viewVars[Inflector::underscore($hlp_sub)];                }            }        }    }    function isAjax()    {        return env('HTTP_X_REQUESTED_WITH') === "XMLHttpRequest";    }    /**     * Redirects to given $url, after turning off $this->autoRender.     * Script execution is halted after the redirect.     *     * @param mixed $url A string or array-based URL pointing to another location within the app,     * or an absolute URL     * @param integer $status Optional HTTP status code (eg: 404)     * @param boolean $exit If true, exit() will be called after the redirect     * @return mixed void if $exit = false. Terminates script if $exit = true     * @access public     * @link http://book.cakephp.org/view/982/redirect     */    function redirect($url, $status = null, $exit = true)    {        $this->autoRender = false;        if (is_array($status)) {            extract($status, EXTR_OVERWRITE);        }        if (function_exists('session_write_close')) {            session_write_close();        }        if (!empty($status)) {            $codes = $this->httpCodes();            if (is_string($status)) {                $codes = array_flip($codes);            }            if (isset($codes[$status])) {                $code = $msg = $codes[$status];                if (is_numeric($status)) {                    $code = $status;                }                if (is_string($status)) {                    $msg = $status;                }                $status = "HTTP/1.1 {$code} {$msg}";            } else {                $status = null;            }            $this->header($status);        }        if ($url !== null) {            $this->header('Location: ' . $url);        }        if (!empty($status) && ($status >= 300 && $status < 400)) {            $this->header($status);        }        if ($exit) {            $this->_stop();        }    }    /**     * Convenience and object wrapper method for header(). Useful when doing tests and     * asserting that particular headers have been set.     *     * @param string $status The header message that is being set.     * @return void     * @access public     */    function header($status)    {        header($status);    }    /**     * Stop execution of the current script. Wraps exit() making     * testing easier.     *     * @param $status see http://php.net/exit for values     * @return void     * @access public     */    function _stop($status = 0)    {        exit($status);    }    var $panels = array();    var $panel_path = array(COMPONENTS);    /**     * @param mixed $panels(list/name panel/s)     * @param mixed $param (param for run method if $panels is string)     * @param mixed $param (param for run method if $panels is string)     * ...     * @param mixed $param (param for run method if $panels is string)     * @return string panel content     */    public $print = true;    function renderPanel($panels, $data = 'assa')    {        $args = func_get_args();        if (is_string($panels)) {            unset($args[0]);            $panels = array($panels => $args);        } else if (!is_array($panels)) {            throw new Exception("Wrong arguments");        }        ob_start();        foreach ($panels AS $panel => $args) {            if (!empty($panel)) {                $class_name = Inflector::camelize("{$panel}_panel");                $component_file = Paths::findPath('panel', Inflector::underscore($class_name) . ".php");                if ($component_file == null) {                    die('Panel file "' . Inflector::underscore($class_name) . ".php" . '" has not been found');                }                require_once($component_file);                if (!isset($this->{$class_name})) {                    $this->{$class_name} = new $class_name();                    $this->{$class_name}->startup($this);                }                $rc = new ReflectionClass($class_name);                if (!$rc->hasMethod("run")) {                    throw new Exception("Panel $class_name don't must be used in panel .");                }                $rm = new ReflectionMethod($this->{$class_name}, 'run');                echo $rm->invokeArgs($this->{$class_name}, $args);            }        }        return ob_get_clean();    }    function __call($func, $args)    {        preg_match("/([a-zA-Z0-9]+)Panel([a-zA-Z0-9]+)?/i", $func, $matches);        $panel = $matches[1];        $one = $matches[2] . "Panel";        if (isset($this->panels[$panel])) {            ob_start();            foreach ($this->panels[$panel] AS $component => $settings) {                if (is_string($settings)) {                    $component = $settings;                }                if ($one != $component && $one != "Panel") {                    continue;                }                $rc = new ReflectionClass($component);                if (!$rc->hasMethod("run")) {                    throw new Exception("Component $component don't must be used in panel .");                }                $rm = new ReflectionMethod($component, 'run');                echo $rm->invokeArgs($this->{$component}, array_merge($settings, $args));            }            return ob_get_clean();        } else {            //$this->{$func}        }        throw new Exception("Method $func is not exist.");    }    /**     * Merge components, helpers, and uses vars from AppController and PluginAppController.     *     * @return void     * @access protected     */    function __mergeVars()    {        $pluginController = 'AppController';        if (is_subclass_of($this, 'AppController') || is_subclass_of($this, $pluginController)) {            $appVars = get_class_vars('AppController');            $uses = $appVars['uses'];            $merge = array('components', 'helpers');            $plugin = null;            if ($uses == $this->uses && !empty($this->uses)) {                if (!in_array($this->modelClass, $this->uses)) {                    array_unshift($this->uses, $this->modelClass);                } elseif ($this->uses[0] !== $this->modelClass) {                    $this->uses = array_flip($this->uses);                    unset($this->uses[$this->modelClass]);                    $this->uses = array_flip($this->uses);                    array_unshift($this->uses, $this->modelClass);                }            } elseif ($this->uses !== null || $this->uses !== false) {                $merge[] = 'uses';            }            foreach ($merge as $var) {                if (!empty($appVars[$var]) && is_array($this->{$var})) {                    $this->{$var} = Set::merge($this->{$var}, array_diff($appVars[$var], $this->{$var}));                }            }        }    }    public function callAction($controller, $action)    {        // for example, to reroute to users/delete        // this is in the controller which receives the request.        // this could even be in the AppController        //code founded at http://stackoverflow.com/questions/1871592/how-to-make-cakephp-redirect-to-a-different-action-controller        $this->autoRender = false;        $d = new Dispatcher();        $d->dispatch(            array("controller" => strtolower($controller), "action" => $action),            array("data" => $this->data)        );    }    protected function _forward($action)    {        $this->$action();        echo $this->render(strtolower($this->name) . '/' . $action);    }    function requestAction($url, $extra = array())    {        //$this->autoRender = false;        if (empty($url)) {            return false;        }        if (in_array('return', $extra, true)) {            $extra = array_merge($extra, array('return' => 0, 'autoRender' => 1));        }        if (is_array($url) && !isset($extra['url'])) {            $extra['url'] = array();        }        $params = array_merge(array('autoRender' => 1, 'return' => 0, 'bare' => 1, 'requested' => 1), $extra);        $dispatcher = new Dispatcher;        return $dispatcher->dispatch($url, $params);    }    /**     * funkce ktera nacte model     * vrati jeho list a unsetne     * @param $model - model pro ktery se ma list nacist     * @param $con - array conditions, am with basic array     * @param $order - classic order string, default is "name ASC"     * @return array list     */    public function get_list($model = null, $con = array(), $order = 'name ASC')    {        if ($model != null) {            $this->loadModel($model);            return $this->$model->get_list($con, $order);            unset($this->$model);        }        else            return false;    }    function panelAction($panelName = null, $actionName = null, $arg = array())    {        if ($panelName == null || $actionName == null) {            log::djf(LANG::get('ajax_panelAction_action_or_panel_name_not_defined'));        }        $class_name = Inflector::camelize("{$panelName}_panel");        $component_file = Paths::findPath('panel', Inflector::underscore($class_name) . ".php");        if ($component_file == null) {            log::djf('Soubor "' . Inflector::underscore($class_name) . ".php" . '" ' . LANG::get('ajax_panelAction_component_not_founded'));        }        require_once($component_file);        if (!isset($this->{$class_name})) {            $this->{$class_name} = new $class_name();            $this->{$class_name}->startup($this);            $output = $this->{$class_name}->{$actionName}($arg);            $this->autoRender = false;        }        return $output;    }}?>